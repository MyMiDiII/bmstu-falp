\chapter{Практические задания}

\section{Задание №1}

Пусть

\vspace{4mm}
\hfill
\begin{minipage}{0.92\linewidth}
\begin{lstlisting}
(setf lst1 '(a b))
(setf lst2 '(c d))
\end{lstlisting}
\end{minipage}

Каковы результаты вычисления следующих выражений?

\vspace{4mm}
\hfill
\begin{minipage}{0.92\linewidth}
\begin{lstlisting}
(cons lst1 lst2)   ; ((a b) c d)
(list lst1 lst2)   ; ((a b) (c d))
(append lst1 lst2) ; (a b c d)
\end{lstlisting}
\end{minipage}

\section{Задание №2}

Каковы результаты вычисления следующих выражений, и почему?

\vspace{4mm}
\begin{minipage}{0.92\linewidth}
\begin{lstlisting}
(reverse ())         ; Nil
(last ())            ; Nil
(reverse '(a))       ; (a)
(last '(a))          ; (a)
(reverse '((a b c))) ; ((a b c))
(last '((a b c)))    ; ((a b c))
\end{lstlisting}
\end{minipage}

\section{Задание №3}

Написать, по крайней мере, два варианта функции, которая возвращает
последний элемент своего списка-аргумента.

\vspace{4mm}
\begin{minipage}{0.92\linewidth}
\begin{lstlisting}
(defun get-last1 (lst)
    (car (last lst))
\end{lstlisting}
\end{minipage}

\vspace{4mm}
\begin{minipage}{0.92\linewidth}
\begin{lstlisting}
(defun get-last2 (lst)
    (if (cdr lst)
        (get-last2 (cdr lst))
        (car lst)))
\end{lstlisting}
\end{minipage}

\vspace{4mm}
\begin{minipage}{0.92\linewidth}
\begin{lstlisting}
(defun get-last3 (lst)
    (car (reverse lst)))
\end{lstlisting}
\end{minipage}

\section{Задание №4}

Написать, по крайней мере, два варианта функции, которая возвращает свой
список-аргумент без последнего элемента.

\vspace{4mm}
\begin{minipage}{0.92\linewidth}
\begin{lstlisting}
(defun get-no-last1 (lst)
    (nreverse (cdr (reverse lst))))
\end{lstlisting}
\end{minipage}

\vspace{4mm}
\begin{minipage}{0.92\linewidth}
\begin{lstlisting}
(defun get-no-last2 (lst)
    (if (cdr lst)
        (cons (car lst) (get-no-last2 (cdr lst)))))
\end{lstlisting}
\end{minipage}

\section{Задание №5}

Написать простой вариант игры в кости, в котором бросаются две правильные
кости. Если сумма выпавших очков равна 7 или 11 --- выигрыш, если выпало (1, 1)
или (6, 6) --- игрок имеет право снова бросить кости, во всех остальных
случаях ход переходит ко второму игроку, но запоминается сумма выпавших очков.
Если второй игрок не выигрывает абсолютно, то выигрывает тот игрок, у которого
больше очков. Результат игры и значения выпавших костей выводить на экран
с помощью функции print.

\mylisting{dice.lisp}{}

\chapter{Теоретические вопросы}

\section{Синтаксическая форма и хранение программы в памяти}

В Lisp и программа, и данные представлены S-выражениями, благодаря чему
программа может обрабатывать и преобразовывать другие программы или саму себя.
S-выражение --- атом или точечная пара. Атом представляется в памяти 5-ю
указателями: имя, значение, функция, свойство, пакет. Точечная пара
представляется в памяти списковой ячейкой: бинарный узел, состоящий из двух
указателей (car-указатель и cdr-указатель).

\section{Трактовка элементов списка}

По умолчанию список является формой (вычислимым выражением), в которой первый
элемент трактуется как имя фунции, остальные элементы --- как ее аргументы.  Для
возможности различия программы от данных создана функция quote и ее сокращенное
обозначение --- апостроф \texttt{'}. Функция quote и апостроф блокируют
вычисление своего аргумента и возращают его текстовую запись.

\section{Порядок реализации программы}

Программа на языке Lisp включает определения новых функций на базе встроенных
функций и другий функций, определенных в этой программе, а также вызовы функций
для конкретных значений аргументов. Последовательность операций достигается
вызовом функций в определенном порядке, т.~е. суперпозицией функций. Передача
данных между функциями выполняется через их аргументы и возвращаемые значения.

Выполнение программы заключается в вычислении значений функций для конкретных
значений аргументов. Вычисление функции происходит с помощью интерпретации
--- функции eval, которая может вычислять значение любой формы. Так как
программа на языке Lisp представлет S-выражение функция eval принимает в
качестве аргумента S-выражение и вычисляет по схеме, представленной на
рисунке~\ref{img:eval}.

\img{10cm}{eval}{Работа функции eval}{eval}

\section{Способы определения функции}

Лямбда определение:

\vspace{4mm}
\begin{minipage}{0.92\linewidth}
\begin{lstlisting}
(lambda <lambda-список> <форма>) ; lambda-выражение
;; <lambda-список> -- список аргументов
;; <форма> -- тело функции
\end{lstlisting}
\end{minipage}

Определение функций с именем:

\vspace{4mm}
\begin{minipage}{0.92\linewidth}
\begin{lstlisting}
(defun <имя> <lambda-выражение>)
\end{lstlisting}
\end{minipage}
